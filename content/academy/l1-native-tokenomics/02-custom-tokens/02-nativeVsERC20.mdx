---
title: Native vs ERC20 Tokens
description: Learn the key differences between native tokens and ERC20 tokens on Avalanche L1s
updated: 2025-08-21
authors: [nicolasarnedo]
icon: BookOpen
---

When designing tokenomics for your Avalanche L1, it's crucial to understand the fundamental differences between native tokens and ERC20 tokens. Each has distinct characteristics that affect how they function within your blockchain ecosystem.

## Key Differences

| Feature | ERC20 | Native |
|---------|-------|--------|
| **Defined By** | Smart Contract Deployer | Protocol Level |
| **Balance Storage** | Mapping in contract storage<br/>`mapping(address => balance)` | EVM Account state<br/>`account.balance` |
| **Transfer Logic** | Handled by contract functions<br/>`transfer()`, `transferFrom()` | Handled by EVM opcodes<br/>`CALL`, `SELFDESTRUCT` |
| **Smart Contract Awareness** | Built-in hooks for DeFi compatibility<br/>Allows programmatic approvals<br/>(e.g., Uniswap, Aave) | Can't call functions<br/>`approve()`, `transferFrom()` |

## The Protocol Limitation

One critical limitation of native tokens is that **protocols cannot "pull" native tokens from your wallet using `transferFrom()`**. This fundamental difference impacts how DeFi protocols interact with native tokens.

## Real-World Example: Aave Lending

Let's look at how supplying ETH (a native token) to Aave works:

1. **Wrap it into WETH** - Convert native ETH to ERC20 WETH
2. **Call `approve()`** - Give Aave permission to spend your WETH
3. **Aave calls `transferFrom()`** - Aave pulls the WETH from your wallet
4. **You receive aTokens** - Start earning interest and can borrow against your deposit

## Why ERC20 Standardization Matters

The main advantage of ERC20 tokens is **standardization**. Without it:
- You could build a `deposit()` payable function for native tokens
- But then you'd have two different logics for depositing tokens
- This creates complexity and potential security issues

## ERC20 as Native Token on L1s

When transferring ERC20 tokens to become native tokens on an L1:
- The token is **transferred to the L1 via ICTT** (Interchain Token Transfer)
- It gets **converted into the Native Token**
- **Important**: The token loses its ERC20 capabilities on the L1

<Callout type="info">
The conversion between ERC20 and native tokens is a one-way bridge when moving to an L1. Understanding these trade-offs is essential for designing your tokenomics.
</Callout>

## When to Use Each

**Use Native Tokens when:**
- You need a gas token for your L1
- You want the simplest implementation
- Smart contract interactions are limited

**Use ERC20 Tokens when:**
- You need DeFi composability
- You require approval mechanisms
- You want to integrate with existing protocols

<Callout type="tip">
Cross-chain native token functionality and advanced ERC20 features will be covered in detail in the **Cross-Chain L1 Native** course.
</Callout>