---
title: Function Flow Breakdown
description: How to interact with precompiles and their protocol-level data changes
updated: 2025-01-15
authors: [nicolasarnedo]
icon: BookOpen
---

## Function Flow Breakdown

Understanding how precompiles are called and how they apply changes at the protocol level is crucial for developers working with advanced blockchain features.

## Calling Precompiles

### From Smart Contracts

Precompiles are called like regular smart contracts using `staticcall`:

```solidity
// Example: Calling SHA-256 precompile
function hashData(bytes memory data) public pure returns (bytes32) {
    bytes32 result;
    assembly {
        let success := staticcall(
            gas(),           // gas limit
            0x02,            // precompile address (SHA-256)
            add(data, 0x20), // input data pointer
            mload(data),     // input data length
            0,               // output data pointer
            0x20             // output data length
        )
        if success {
            result := mload(0)
        }
    }
    return result;
}
```

### From Developer Console

The Developer Console provides user-friendly interfaces for common precompile operations:

- **Cryptographic Tools**: Hash functions, signature verification
- **Advanced Math**: Modular exponentiation, elliptic curve operations
- **Data Processing**: Identity functions, data manipulation

## Protocol-Level Data Changes

<Mermaid chart="sequenceDiagram
    participant SC as Smart Contract
    participant EVM as EVM Interpreter
    participant PC as Precompile Handler
    participant CL as Client Layer
    participant CS as Consensus State
    participant BS as Blockchain State

    SC->>EVM: Call precompile address
    EVM->>PC: Route to precompile
    PC->>CL: Execute native code
    CL->>CS: Modify protocol data
    CS->>BS: Update blockchain state
    BS-->>CL: State updated
    CL-->>PC: Return result
    PC-->>EVM: Return data
    EVM-->>SC: Return result
"/>

## How Precompiles Apply Changes

### 1. **Immediate Execution**
- Precompiles execute **synchronously** during transaction processing
- Changes are applied **immediately** to the blockchain state
- No additional confirmation or mining required

### 2. **Protocol State Modification**
- Direct modification of **consensus-critical data**
- Changes affect **block validation** and **state transitions**
- **Atomic operations** - either fully succeed or fully fail

### 3. **Gas and Fee Handling**
- Precompiles consume **fixed gas costs**
- Gas is deducted **before execution**
- **No refunds** for failed precompile calls

## Real-World Example: Signature Recovery

```solidity
// Using ecrecover precompile (0x01)
function verifySignature(
    bytes32 messageHash,
    uint8 v,
    bytes32 r,
    bytes32 s
) public pure returns (address) {
    return ecrecover(messageHash, v, r, s);
}
```

**What happens at the protocol level:**
1. EVM recognizes address `0x01` as precompile
2. Routes call to native signature recovery code
3. Executes cryptographic verification
4. Returns recovered address
5. **No state changes** (pure function)

## Advanced Example: Modular Exponentiation

```solidity
// Using modExp precompile (0x05)
function modularExponentiation(
    uint256 base,
    uint256 exponent,
    uint256 modulus
) public view returns (uint256) {
    // Complex mathematical operation
    // Would be extremely expensive as smart contract
    // Precompile makes it feasible
}
```

**Protocol-level impact:**
- Enables **zero-knowledge proofs**
- Supports **advanced cryptography**
- **Critical for privacy protocols**

## Continuous Chain Operation

<Callout type="warning">
**Important**: Precompiles execute **during block processing**, not after. This means:
- Changes are **immediately visible** in the next block
- **No waiting** for additional confirmations
- **Consensus-critical** operations happen in real-time
</Callout>

### Block Processing Flow

1. **Transaction Validation**: Precompiles validate inputs
2. **Execution**: Native code runs with full protocol access
3. **State Update**: Changes applied to blockchain state
4. **Block Finalization**: Updated state included in block
5. **Next Block**: Changes are immediately available

## Developer Considerations

**When to Use Precompiles:**
- Complex cryptographic operations
- Mathematical computations
- Data processing that would be expensive in EVM
- Operations requiring protocol-level access

**Best Practices:**
- Always handle precompile failures gracefully
- Understand gas costs before implementation
- Test thoroughly as precompiles can't be debugged like smart contracts
- Consider the protocol-level implications of your operations

Precompiles bridge the gap between smart contract flexibility and protocol-level efficiency, enabling advanced blockchain applications while maintaining the security and determinism of the EVM execution model.